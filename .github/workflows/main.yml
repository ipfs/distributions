name: CI

on:
  push:
# TODO: restore after testing
#    branches:
#      - master
#  pull_request:
#    branches:
#      - master

env:
 # TODO: remove after testing
  DIST_ROOT: '/ipfs/QmX6J3hVtMF9Y73CKcyLHfgviEfXGFFQABWPXsD17EsBhg' # dist.ipfs.io without ipfs-update@v1.7.1

jobs:
  build:
    runs-on: "ubuntu-latest"
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install ipfs and deps
        run: |
          # set up go-ipfs
          IPFS_VERSION=$(curl -s https://dist.ipfs.io/go-ipfs/versions | tail -n 1)
          tar xzf <(curl -s https://dist.ipfs.io/go-ipfs/${IPFS_VERSION}/go-ipfs_${IPFS_VERSION}_linux-amd64.tar.gz)
          echo "${{ github.workspace }}/go-ipfs/" >> $GITHUB_PATH
          # set up ipfs-cluster-ctl
          CTL_VERSION=$(curl -s https://dist.ipfs.io/ipfs-cluster-ctl/versions | tail -n 1)
          tar xzf <(curl -s https://dist.ipfs.io/ipfs-cluster-ctl/${CTL_VERSION}/ipfs-cluster-ctl_${CTL_VERSION}_linux-amd64.tar.gz)
          echo "${{ github.workspace }}/ipfs-cluster-ctl/" >> $GITHUB_PATH
      - name: Fix resolv # DNS provided by Github is unreliable for DNSLik/dnsaddr
        run: sudo sed -i -e 's/nameserver 127.0.0.*/nameserver 1.1.1.1/g' /etc/resolv.conf
      - name: Set up ipfs
        run: |
          ipfs init --profile flatfs,server,test,lowpower
          # make flatfs async for faster ci
          new_config=$( jq '.Datastore.Spec.mounts[0].child.sync = false' ~/.ipfs/config) && echo "${new_config}" > ~/.ipfs/config
          # restore deterministic port (changed by test profile)
          ipfs config Addresses.API "/ip4/127.0.0.1/tcp/5001"
      - name: Wait for ipfs daemon
        run: ipfs daemon --enable-gc=false & while (! ipfs id --api "/ip4/127.0.0.1/tcp/5001"); do sleep 1; done
        timeout-minutes: 3
      - name: Preconnect to cluster peers
        run: |
          echo '-> preconnect to cluster peers'
          ipfs-cluster-ctl --enc=json \
            --host "/dnsaddr/ipfs-websites.collab.ipfscluster.io" \
            --basic-auth '${{ secrets.CLUSTER_USER }}:${{ secrets.CLUSTER_PASSWORD }}' \
            peers ls > cluster-peers-ls
          for maddr in $(jq -r '.[].ipfs.addresses[]' cluster-peers-ls); do
            ipfs swarm connect "$maddr" || continue
          done
          echo '-> manual connect to cluster.ipfs.io'
          ipfs swarm connect /dnsaddr/cluster.ipfs.io
          echo '-> list swarm peers'
          ipfs swarm peers
        timeout-minutes: 3
      - name: Build any new ./releases
        run: ./dockerized make all_dists
      - name: Inspect git status and contents of ./releases
        run: git status && ls -Rhl ./releases
      - name: Temporarily save ./releases artifacts
        uses: actions/upload-artifact@v2
        with:
          name: releases-unsigned-diff
          path: releases
          retention-days: 1

  lint:
    runs-on: "ubuntu-latest"
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm ci --no-audit --progress=false
      - run: npm run lint

  sign-macos:
    runs-on: "macos-latest"
    needs: build
    steps:
      - uses: actions/checkout@v2
      - name: Retrieve unsigned artifacts
        uses: actions/download-artifact@v2
        with:
          name: releases-unsigned-diff
          path: releases
      - name: List ./releases before
        run: ls -Rhl ./releases
      - name: Install gon via HomeBrew for code signing and app notarization
        run: |
          brew tap mitchellh/gon
          brew install ipfs coreutils gawk gnu-sed jq mitchellh/gon/gon
          ipfs init --profile test # needed for calculating NEW_CID later
      - name: Import Keychain Certs
        uses: apple-actions/import-codesign-certs@253ddeeac23f2bdad1646faac5c8c2832e800071 # v1@2020-02-03
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTS_P12 }}
          p12-password: ${{ secrets.APPLE_CERTS_PASS }}
      - name: Verify identity used for signing
        run: security find-identity -v
      - name: Unpack any new darwin arm64 and amd64 binaries to ./tmp
        run: |
          # ./releases/{DIST_NAME}/{DIST_VERSION}/*_darwin-${arch}.tar.gz -> ./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              mkdir -p "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned"
              tar -zxvf "./releases/${DIST_NAME}/${DIST_VERSION}/${DIST_NAME}_${DIST_VERSION}_darwin-${arch}.tar.gz" -C "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/"
            done
          done
          ls -Rhl ./tmp
      - name: Sign and notarize the mac binaries
        env:
          AC_USERNAME: ${{ secrets.APPLE_AC_USERNAME }} # implicitly read from env by gon
          AC_PASSWORD: ${{ secrets.APPLE_AC_PASSWORD }}
        run: |
          # Find and sign executables in ./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              EXECUTABLES=$(jq -nc '$ARGS.positional' --args $(find "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/" -perm +111 -type f -print))
              echo "{
                  \"source\" : $EXECUTABLES,
                  \"bundle_id\" : \"io.ipfs.dist.${DIST_NAME}\",
                  \"apple_id\": {
                    \"password\":  \"@env:AC_PASSWORD\"
                  },
                  \"sign\" :{
                    \"application_identity\" : \"Developer ID Application: Protocol Labs, Inc. (7Y229E2YRL)\"
                  },
                  \"zip\" :{
                      \"output_path\" : \"./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed.zip\"
                  }
              }" | tee | jq > "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-gon.json"
              gon -log-level=info -log-json "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-gon.json"
            done
          done
      - name: Temporarily save ./tmp
        uses: actions/upload-artifact@v2
        with:
          name: tmp
          path: ./tmp/
          retention-days: 1
      - name: Update changed binaries in ./releases
        run: |
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              echo "-> Starting the update of darwin_${arch}.tar.gz for name='${DIST_NAME}' and version='${DIST_VERSION}'"
              # unzip signed binaries to a directory matching .tar.gz structure
              cd "${{ github.workspace }}"
              mkdir -p "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/${DIST_NAME}"
              cd "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/${DIST_NAME}/"
              echo "-> Unpacking gon .zip for ${arch}"
              unzip "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed.zip"
              echo "-> Unpacked contents"
              ls -Rhl "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/"
              # replace .tar.gz with one that has the same structure, but signed binaries
              PKG_NAME="${DIST_NAME}_${DIST_VERSION}_darwin-${arch}.tar.gz"
              PKG_ROOT="${{ github.workspace }}/releases/${DIST_NAME}/${DIST_VERSION}"
              PKG_PATH="${PKG_ROOT}/${PKG_NAME}"
              DIST_JSON="${PKG_ROOT}/dist.json"
              # read old hashes
              OLD_CID=$(cat "${PKG_PATH}.cid")
              OLD_SHA512=$(gawk '{ print $1; }' < "${PKG_PATH}.sha512")
              echo "-> Found old $PKG_NAME"
              echo "   old CID:    $OLD_CID"
              echo "   old SHA512: $OLD_SHA512"
              echo "-> Updating $PKG_NAME"
              rm "$PKG_PATH"
              tar -czvf "${{ github.workspace }}/releases/${DIST_NAME}/${DIST_VERSION}/$PKG_NAME" -C "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/" "${DIST_NAME}"
              # calculate new hashes
              NEW_CID=$(ipfs add -Qn "$PKG_PATH")
              NEW_SHA512_LINE=$(gsha512sum "$PKG_PATH")
              NEW_SHA512=$(echo "$NEW_SHA512_LINE" | gawk '{ print $1; }')
              echo "-> New $PKG_NAME"
              echo "   new CID:    $NEW_CID"
              echo "   new SHA512: $NEW_SHA512"
              # update metadata to use new hashes
              echo "$NEW_CID" > "${PKG_PATH}.cid"
              echo "$NEW_SHA512_LINE" > "${PKG_PATH}.sha512"
              gsed -i "s/${OLD_CID}/${NEW_CID}/g; s/${OLD_SHA512}/${NEW_SHA512}/g" "${PKG_ROOT}/dist.json"
              echo "-> Completed the update of ${arch}.tar.gz for ${DIST_NAME} ${DIST_VERSION}"
            done
          done
      - name: List ./releases after
        run: ls -Rhl ./releases
      - name: Temporarily save notarized artifacts
        uses: actions/upload-artifact@v2
        with:
          name: releases-signed-macos-diff
          path: releases
          retention-days: 1

  persist:
    runs-on: "ubuntu-latest"
    needs: sign-macos
    steps:
      - uses: actions/checkout@v2
      - name: Retrieve signed artifacts
        uses: actions/download-artifact@v2
        with:
          name: releases-signed-macos-diff
          path: releases
      - name: List ./releases
        run: ls -Rhl ./releases
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install ipfs and deps
        run: |
          # set up go-ipfs
          IPFS_VERSION=$(curl -s https://dist.ipfs.io/go-ipfs/versions | tail -n 1)
          tar xzf <(curl -s https://dist.ipfs.io/go-ipfs/${IPFS_VERSION}/go-ipfs_${IPFS_VERSION}_linux-amd64.tar.gz)
          echo "${{ github.workspace }}/go-ipfs/" >> $GITHUB_PATH
          # set up ipfs-cluster-ctl
          CTL_VERSION=$(curl -s https://dist.ipfs.io/ipfs-cluster-ctl/versions | tail -n 1)
          tar xzf <(curl -s https://dist.ipfs.io/ipfs-cluster-ctl/${CTL_VERSION}/ipfs-cluster-ctl_${CTL_VERSION}_linux-amd64.tar.gz)
          echo "${{ github.workspace }}/ipfs-cluster-ctl/" >> $GITHUB_PATH
      - name: Fix resolv # DNS provided by Github is unreliable for DNSLik/dnsaddr
        run: sudo sed -i -e 's/nameserver 127.0.0.*/nameserver 1.1.1.1/g' /etc/resolv.conf
      - name: Set up ipfs
        run: |
          ipfs init --profile flatfs,server,test,lowpower
          # make flatfs async for faster ci
          new_config=$( jq '.Datastore.Spec.mounts[0].child.sync = false' ~/.ipfs/config) && echo "${new_config}" > ~/.ipfs/config
          # restore deterministic port (changed by test profile)
          ipfs config Addresses.API "/ip4/127.0.0.1/tcp/5001"
      - name: Wait for ipfs daemon
        run: ipfs daemon --enable-gc=false & while (! ipfs id --api "/ip4/127.0.0.1/tcp/5001"); do sleep 1; done
        timeout-minutes: 3
      - name: Preconnect to cluster peers
        run: |
          echo '-> preconnect to cluster peers'
          ipfs-cluster-ctl --enc=json \
            --host "/dnsaddr/ipfs-websites.collab.ipfscluster.io" \
            --basic-auth '${{ secrets.CLUSTER_USER }}:${{ secrets.CLUSTER_PASSWORD }}' \
            peers ls > cluster-peers-ls
          for maddr in $(jq -r '.[].ipfs.addresses[]' cluster-peers-ls); do
            ipfs swarm connect "$maddr" || continue
          done
          echo '-> manual connect to cluster.ipfs.io'
          ipfs swarm connect /dnsaddr/cluster.ipfs.io
          echo '-> list swarm peers'
          ipfs swarm peers
        timeout-minutes: 3
      - run: make publish
      - run: git status
      - name: Read CID of updated DAG
        id: cid-reader
        run: echo "::set-output name=CID::$(tail -1 ./versions)"
      - name: Pin new website to ipfs-websites.collab.ipfscluster.io
        run: |
          echo 'pin to cluster'
          ipfs-cluster-ctl --enc=json \
            --host "/dnsaddr/ipfs-websites.collab.ipfscluster.io" \
            --basic-auth '${{ secrets.CLUSTER_USER }}:${{ secrets.CLUSTER_PASSWORD }}' \
            pin add \
            --pin-name="https://github.com/ipfs/distributions/commits/${{ github.sha }}" \
            --no-status \
            "${{ steps.cid-reader.outputs.CID }}"
          while true; do
            ipfs-cluster-ctl --enc=json \
              --host "/dnsaddr/ipfs-websites.collab.ipfscluster.io" \
              --basic-auth '${{ secrets.CLUSTER_USER }}:${{ secrets.CLUSTER_PASSWORD }}' \
              status "${{ steps.cid-reader.outputs.CID }}" | tee cluster-pin-status
            if [[ $(jq '.peer_map[].status' cluster-pin-status | grep '"pinned"' | wc -l) -ge 2 ]]; then
              echo "Got 2 pin confirmations, finishing the workflow"
              break
            else
              echo "(sleeping for 15 seconds)"
              sleep 15
            fi
          done
        timeout-minutes: 60
      # TODO: update PR status with preview link
      # - uses: ipfs-shipyard/ipfs-github-action@51639f910548de983b3f49b209bc23e0cf997b14 # https://github.com/ipfs-shipyard/ipfs-github-action/pull/7
      #  id: ipfs
      #  with:
      #    path_to_add: /ipfs/${{ steps.cid-reader.outputs.CID }}
      #    cluster_host: /dnsaddr/ipfs-websites.collab.ipfscluster.io
      #    cluster_user: ${{ secrets.CLUSTER_USER }}
      #    cluster_password: ${{ secrets.CLUSTER_PASSWORD }}
      #  env:
      #    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #- run: echo ${{ steps.ipfs.outputs.url }}
      #- run: echo ${{ github.ref }}
